//// 测试：结构体A的指针，指向结构体B，并进行访问
///*
// * 测试结论
// *
// * 1. 指针的类型，决定了指定的内存如何修改
// * 2. 指定的内存，决定这块区域有多大，能否被修改，
// *    它提供的就是一块内存区域，以及这块区域的大小，
// *    指针可以对区域内的内存任意修改，但是不能越界，
// *    否则就会发生栈破坏，因为局部变量是存在于栈内的，
// *    不能越界【缓冲区溢出、栈溢出实验？】
// * 3. 如果指针的类型是结构体，它其实于指针类型是int，
// *    没有本质的差别，只不过访问的方式比int特殊，例如
// *    对于struct A *ap = &b，它的指针指向了一块儿内存区域，那么
// *    当使用 ap->a 的时候，就相当于 char a ，是以char大小
// *    对它进行访问的（祈使地址就是从开头开始，因为char a
// *    就在开头）如果访问 ap->b，则会从ap+4的地址开始，
// *    按照 int b 来访问内存，因为涉及到字节对齐，这也是
// *    遵循 struct A 自己的规则来。
// * 4. 注意结构体的字节对齐，以及分配虚拟地址时候的字节对齐
// *
// * 5. 【小结】
// *    对于局部变量，它在当前函数栈内被分配了一块内存空间，
// *    对于这块空间，你可以使用各种数据类型的指针指向它（获取它的地址），
// *    然后，只要在这块儿空间内，你就可以，可劲儿造！
// *    至于怎么改，改多大，取决于指针的数据类型。
// *    这样看来其实就是一个自由王国了，
// *    只有【一定大小的、已知地址的内存】和【不同尺寸的指针】，
// *    然后你就想怎么改都行。
// *    这就好比【一块固定大小的蛋糕】和【不同大小的刀叉】
// *
// * 6. 【其实上面的都可以不管！】
// *    直接看反汇编代码，你就知到它们的实际操作是什么了，
// *    上面相当于C语言层级的理解，现在相当于汇编层级的理解
// *    底层理解起来非常清澈见底，很容易的
// * 7. 这也是编译器的作用，实际计算机就会那么几件事，但是人类就靠
// *    那么几个操作虽然能够干出来，但是太慢了，所以有了更容易人类
// *    使用的高级语言，但是最终还是那么几件事，真想看难以理解的
// *    C语言语句，是什么意思，看看汇编语言，就能够立马知到了（不要优化）！
// *    实在看不懂，那就靠C语言来调试好了。
// */
//#include <stdio.h>
//#include <stdlib.h>
//
//struct A {
//	char a;
//	int b;
//};
//
//struct B {
//	int c;
//	int d;
//};
//
//struct C {
//	int e;
//	char f;
//};
//
//
//
//int main88() {
//
//
//	char aaa[4] = { 1,2,3,4 };
//	char aaa2[4] = { 1,2,3,4 }; // 两个char数组不连续
//	int *bbb = aaa; // int *bbb = aaa; 亦可
//	printf("\n\n0x%x\n\n\n", bbb[0]);	// 0x04030201
//	printf("\n\n0x%x\n\n\n", *bbb);		// 0x04030201
//
//	printf("%d\n", sizeof(aaa));
//	printf("%d\n", aaa);
//	printf("%d\n", &aaa);
//
//	
//
//	struct A a = { 'a', 100 };
//	struct B b = { 101, 300 };
//	struct C c = { 200,'c' };
//
//	// 根据字节对齐，都占据8字节
//	printf("A: size %d  %c  %d\n", sizeof(a), a.a, a.b);
//	printf("B: size %d  %d  %d\n", sizeof(b), b.c, b.d);
//	printf("C: size %d  %d  %c\n", sizeof(c), c.e, c.f);
//
//
//	struct A *ap = &b; // A结构体指针，指向结构体B
//	printf("%d %d\n",ap->a, ap->b);
//	printf("%c %d\n", ap->a, ap->b);
//
//	char *chp = &b;
//	chp[1] = 'b';  // 这块区域其实是字节对齐导致的空闲空间
//	printf("%d %d\n", ap->a, ap->b);
//	printf("%c %d\n", ap->a, ap->b);
//
//	/* 如何访问这块内存，取决于ap指针，能访问多大地方，取决于内存区域本身 */
//	ap->a = 'c';  // ap->a = 'c'就是相当于 char a = 'c';
//	ap->a = 1000; // ap->a = 1000 就是相当于 char a = 1000; 1000过大会被截断高位
//	ap->b = 3000; // ap->b <=> int b ...
//
//	struct C *cp = &b; // C结构体指针，指向结构体B
//	printf("%d %d\n", cp->e, cp->f);
//	printf("%d %c\n", cp->e, cp->f);
//
//	cp->e = 3000;
//	cp->f = 'e';
//	cp->f = 1000;
//	
//
//	// 整形指针指向结构体A
//	int *bp = &a;
//	bp[0] = 1000;
//	bp[1] = 2000;
//	printf("A: %c  %d\n", a.a, a.b);
//	printf("A: %d  %d\n", a.a, a.b);
//	// bp[2] = 2000;	// 可以修改内存，但是堆栈溢出，
//						// 因为该空间没有被分配（局部变量是保存在堆栈中的）
//
//	return 0;
//}